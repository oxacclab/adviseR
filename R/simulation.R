#' Run the simulation
#' @param n_agents number of nodes in the network
#' @param n_decisions number of decisions to simulate
#' @param conf whether or not agents use confidence to update trust
#' @param bias_mean the mean for the agents' bias distribution (agents' biases
#'   are drawn from normal distributions with mean +/- biasMean)
#' @param bias_sd standard deviation for the bias distribution
#' @param sensitivity_sd standard deviation for distribution of agents'
#'   sensitivity (mean is 1)
#' @param trust_volatility_mean the mean volatility of agents' trust
#' @param trust_volatility_sd standard deviation
#' @param bias_volatility_mean the mean volatility of agents' biases (move this
#'   proportion towards the final decision value from current bias at each step)
#' @param bias_volatility_sd standard deviation
#' @param starting_graph single number, vector, or n_agents-by-n_agents matrix
#'   of starting trust weights between agents. Coerced to numeric
#' @param randomSeed the random seed to start the simulation with
#'
#' @return a list with \itemize{
#'  \item{"times"}{Timestamps associated with simulation stages.}
#'  \item{"parameters"}{Parameters input into the model}
#'  \item{"model"}{A list of model content \itemize{
#'    \item{"agents"}{A tbl with 1 row for each decision made by an agent.}
#'    \item{"graphs"}{Annotated igraphs of trust strength between agents at each
#'    generation.}
#'  }}
#' }
#'
#' @importFrom stats runif
#' @importFrom withr with_seed
#'
#' @export
runSimulation <- function(
  n_agents = 6,
  n_decisions = 200,
  conf = T,
  bias_mean = 1,
  bias_sd = 1,
  sensitivity_sd = 1,
  trust_volatility_mean = .05,
  trust_volatility_sd = .01,
  bias_volatility_mean = .05,
  bias_volatility_sd = .01,
  starting_graph = NULL,
  randomSeed = NA
) {

  # print(paste0(
  #   "Running simulation: ",
  #   "; AgentCount = ", n_agents,
  #   "; DecisionCount = ", n_decisions,
  #   "; BiasMean = ", bias_mean,
  #   " (SD = ", bias_sd, ")",
  #   "; sensitivitySD = ", sensitivity_sd,
  #   "; TrustVolatility = ", trust_volatility_mean,
  #   " (SD = ", trust_volatility_sd, ")",
  #   "; BiasVolatility = ", bias_volatility_mean,
  #   " (SD = ", bias_volatility_sd, ")",
  # ))

  if (is.na(randomSeed))
    randomSeed = round(runif(1, 1e6, 1e8))  # random random seed

  with_seed(
    as.integer(randomSeed),
    {
      out <- list(
        times = list(
          start = Sys.time()
        ),
        parameters = list(
          n_agents = n_agents,
          n_decisions = n_decisions,
          conf = as.logical(conf),
          bias_mean = bias_mean,
          bias_sd = bias_sd,
          sensitivity_sd = sensitivity_sd,
          trust_volatility_mean = trust_volatility_mean,
          trust_volatility_sd = trust_volatility_sd,
          bias_volatility_mean = bias_volatility_mean,
          bias_volatility_sd = bias_volatility_sd,
          starting_graph = class(starting_graph)[1],
          randomSeed = .Random.seed[length(.Random.seed)]
        )
      )

      # Construct the agents
      out$model <- makeAgents(
        n_agents = n_agents,
        n_decisions = n_decisions,
        bias_mean = bias_mean,
        bias_sd = bias_sd,
        sensitivity_sd = sensitivity_sd,
        trust_volatility_mean = trust_volatility_mean,
        trust_volatility_sd = trust_volatility_sd,
        bias_volatility_mean = bias_volatility_mean,
        bias_volatility_sd = bias_volatility_sd,
        starting_graph = starting_graph
      )

      out$times$agentsCreated <- Sys.time()

      # Run the model
      for (d in 1:n_decisions)
        out <- simulationStep(out, d)
    }
  )

  out$times$end <- Sys.time()

  detailGraphs(out)
}

#' Run a suite of simulations defined by params
#' @param params dataframe of parameters for simulations (see \code{runSimulation()} for details)
#' @param cores number of cores to use in the cluster
#' @inheritDotParams parallel::makeCluster
#'
#' @importFrom parallel makeCluster stopCluster parLapply
#'
#' @export
runSimulations <- function(params, cores = parallel::detectCores(), ...) {
  cl <- parallel::makeCluster(cores, ...)
  out <- parallel::parApply(cl, params, 1, function(p) {
    library(adviseR)
    do.call(runSimulation, as.list(p))
  })
  parallel::stopCluster(cl)
  out
}

#' Each timestep agents are asked for a binary decision about whether a variable
#' is > 0. They form a noisy initial decision based on the true value plus their
#' bias plus noise. They then give their opinion to another agent, and receive
#' another agent's opinion as advice. The advice is integrated according to the
#' current weight placed on the other agent's trustworthiness. This weight is
#' then updated according to whether the agents agree, weighted by the
#' confidence of the deciding agent.
#' @param model to simulate the step for
#' @param d decision to simulate
#'
#' @importFrom stats rnorm
#'
#' @return model updated to include values for decision d
simulationStep <- function(model, d) {
  # identify the agent tibble rows corresponding to decision d
  rows <- (
    ((d - 1) * model$parameters$n_agents):(d * model$parameters$n_agents - 1)
    ) + 1

  agents <- model$model$agents[rows, ]

  # Truth
  agents$truth <- rnorm(1)  # single true value for all agents

  # Initial decisions
  agents$initial <-
    agents$truth +    # true value
    agents$bias +     # bias
    rnorm(model$parameters$n_agents, 0, 1/agents$sensitivity) # normally distributed noise with sd = 1/sensitivity

  # Advice
  agents$advisor <- sapply(agents$id, function(i)
    base::sample((1:model$parameters$n_agents)[-i], # never ask yourself!
                 1))

  agents$weight <- diag(model$model$graphs[[d]][agents$advisor, ])

  agents$advice <-
    agents$initial[agents$advisor]

  agents$final <-
    (agents$initial * (1 - agents$weight)) +
    (agents$advice * agents$weight)

  # Write output to the model
  model$model$agents[rows, ] <- agents

  # Updating bias for next time
  if (max(rows) != nrow(model$model$agents)) {
    # Nudge bias towards observed (i.e. based on final decision) truth
    model$model$agents[rows + model$parameters$n_agents, "bias"] <-
      agents$bias * (1 - agents$bias_volatility) +
      agents$final * agents$bias_volatility
  }

  # Updating weights
  newWeights <- as.vector(model$model$graphs[[d]])
  if (model$parameters$conf) {
    newWeights[(agents$id - 1) * model$parameters$n_agents + agents$advisor] <-
      newWeights[(agents$id - 1) * model$parameters$n_agents + agents$advisor] +
      ifelse((agents$initial > 0) == (agents$advice > 0),
             agents$trust_volatility * abs(agents$initial), # agree
             -agents$trust_volatility * abs(agents$initial)) # disagree
  } else {
    newWeights[(agents$id - 1) * model$parameters$n_agents + agents$advisor] <-
      newWeights[(agents$id - 1) * model$parameters$n_agents + agents$advisor] +
      ifelse((agents$initial > 0) == (agents$advice > 0),
             agents$trust_volatility, -agents$trust_volatility)
  }
  newWeights <- pmax(0.0001, pmin(1, newWeights))
  newWeights <- matrix(newWeights, model$parameters$n_agents, model$parameters$n_agents)
  diag(newWeights) <- 0
  model$model$graphs[[d + 1]] <- newWeights

  model
}
